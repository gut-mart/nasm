==============================================================================
 RUTA: ./lib/cnv/lib_cnv_uint32_to_str.asm
==============================================================================
; ==============================================================================
; RUTA: ./lib/cnv/lib_cnv_uint32_to_str.asm
; DESCRIPCIÓN: Convierte un uint32 a string en la BASE especificada.
;
; ENTRADA:
;   RDI = Puntero al buffer de destino
;   ESI = Número entero sin signo (32 bits) a convertir
;   EDX = Base numérica (Ej: 10 para Decimal, 2 para Binario, 16 para Hex)
;
; SALIDA:
;   RAX = Puntero al inicio de la cadena (el mismo que RDI original)
;   El buffer en RDI contendrá la cadena terminada en 0.
; ==============================================================================

default rel
section .text
    global lib_cnv_uint32_to_str

lib_cnv_uint32_to_str:
    ; --- PRÓLOGO STANDARD ---
    push rbp
    mov rbp, rsp
    
    push rbx            ; Guardamos RBX (Callee-saved)
    push rdi            ; Guardamos RDI (Buffer). 
                        ; En la pila: [RBP] -> [RBX] -> [RDI]
                        ; Por tanto, RDI está en [RBP - 16]

    ; --- VALIDACIÓN DE BASE ---
    cmp edx, 2
    jge .preparar
    mov edx, 10         ; Si base < 2, forzar base 10

.preparar:
    mov eax, esi        ; EAX = Número a convertir (Dividendo)
    mov r8d, edx        ; R8D = Base (Divisor). Usamos R8 porque DIV destruye RDX
    xor ebx, ebx        ; EBX = Contador de dígitos

    ; --- BUCLE DE DIVISIÓN ---
.bucle_division:
    xor edx, edx        ; Limpiar parte alta (EDX:EAX)
    div r8d             ; EAX / Base --> Cociente en EAX, Resto en EDX
    
    ; Convertir resto a ASCII
    cmp edx, 9
    ja .es_letra        ; Si es > 9 (Hexadecimal)

    add edx, '0'        ; 0-9 -> ASCII
    jmp .push_digito

.es_letra:
    add edx, 'A' - 10   ; 10-35 -> 'A'-'Z'

.push_digito:
    push rdx            ; Guardamos el carácter en la pila
    inc ebx             ; Aumentamos contador
    
    test eax, eax       ; ¿Queda número?
    jnz .bucle_division ; Si cociente != 0, repetir

    ; --- RECUPERACIÓN (CORRECCIÓN DEL ERROR) ---
    ; NO hacemos 'pop rdi' aquí porque la pila está llena de dígitos.
    ; Leemos el valor original directamente usando RBP.
    
    mov rdi, [rbp - 16] ; Recuperamos la dirección inicial del buffer
    mov rax, rdi        ; Preparamos valor de retorno

    ; --- BUCLE DE ESCRITURA ---
.escribir:
    pop rdx             ; Sacamos un dígito de la pila
    mov [rdi], dl       ; Escribimos en el buffer
    inc rdi             ; Avanzamos puntero del buffer
    dec ebx             ; Decrementamos contador
    jnz .escribir       ; Si quedan dígitos, repetir

    mov byte [rdi], 0   ; Terminador nulo al final

    ; --- EPÍLOGO ---
    ; La pila ahora tiene [RBX] y [RDI] guardados.
    ; Los dígitos ya se fueron.
    
    pop rdi             ; Limpiamos el RDI que guardamos al principio
    pop rbx             ; Restauramos el RBX original
    
    leave               ; Restaura RSP y RBP
    ret


==============================================================================
 RUTA: ./lib/cnv/lib_cnv_uint32_to_str.inc
==============================================================================
; Este archivo está reservado para constantes futuras de la librería.
; Por ahora no se requiere ninguna estructura ni constante.    


==============================================================================
 RUTA: ./lib/constants.inc
==============================================================================
; ==============================================================================
; RUTA: lib/constants.inc
; DESCRIPCIÓN: Constantes globales del sistema (Linux x86_64)
; ==============================================================================

; --- Descriptores de Archivo ---
STDIN       equ 0
STDOUT      equ 1
STDERR      equ 2

; --- Números de Syscall ---
SYS_READ    equ 0
SYS_WRITE   equ 1
SYS_EXIT    equ 60

; --- Códigos de Salida ---
EXIT_SUCCESS equ 0


==============================================================================
 RUTA: ./lib/graph/lib_graph_get_info_screen.asm
==============================================================================
; ==============================================================================
; RUTA: ./lib/graph/lib_graph_get_info_screen.asm
; DESCRIPCIÓN: Obtiene resolución (PX) y tamaño físico (MM) del Framebuffer
; ==============================================================================

default rel
%include "lib/graph/lib_graph_get_info_screen.inc"

section .data
    fb_path db "/dev/fb0", 0

section .text
    global lib_graph_get_info_screen

; ENTRADA: RDI = Puntero a estructura ScreenInfo (debe tener 24 bytes)
; SALIDA:  RAX = 0 (Éxito) o -1 (Error)
lib_graph_get_info_screen:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13

    mov r12, rdi            ; Guardamos el puntero de usuario (ScreenInfo)

    ; --------------------------------------------------------------------------
    ; 1. ABRIR /dev/fb0
    ; --------------------------------------------------------------------------
    mov rax, 2              ; SYS_OPEN
    lea rdi, [fb_path]
    mov rsi, 0              ; O_RDONLY
    syscall
    
    cmp rax, 0
    jl .error
    mov rbx, rax            ; Guardamos el File Descriptor (FD)

    ; --------------------------------------------------------------------------
    ; 2. RESERVAR BUFFER TEMPORAL EN STACK
    ; La estructura del kernel fb_var_screeninfo mide 160 bytes.
    ; Reservamos espacio para que ioctl escriba todo ahí sin romper nada.
    ; --------------------------------------------------------------------------
    sub rsp, 160            ; Reservamos 160 bytes en la pila

    ; --------------------------------------------------------------------------
    ; 3. LLAMADA IOCTL (FBIOGET_VSCREENINFO)
    ; --------------------------------------------------------------------------
    mov rax, 16             ; SYS_IOCTL
    mov rdi, rbx            ; FD
    mov rsi, 0x4600         ; Comando: Dame info variable
    mov rdx, rsp            ; Escribe los datos en el STACK (RSP)
    syscall

    cmp rax, 0
    jl .error_close

    ; --------------------------------------------------------------------------
    ; 4. EXTRAER DATOS (COPIAR DEL STACK A LA ESTRUCTURA DE USUARIO)
    ; --------------------------------------------------------------------------
    
    ; --- Resolución en Píxeles ---
    mov eax, [rsp + 0]      ; xres (Offset 0 del kernel)
    mov [r12 + ScreenInfo.width], eax

    mov eax, [rsp + 4]      ; yres (Offset 4 del kernel)
    mov [r12 + ScreenInfo.height], eax

    mov eax, [rsp + 24]     ; bits_per_pixel (Offset 24 del kernel)
    mov [r12 + ScreenInfo.bpp], eax

    ; --- Dimensiones Físicas (¡LO NUEVO!) ---
    ; Según <linux/fb.h>: 
    ; offset 88 (0x58) = height in mm
    ; offset 92 (0x5C) = width in mm
    
    mov eax, [rsp + 92]     ; width (mm)
    mov [r12 + ScreenInfo.phy_width], eax
    
    mov eax, [rsp + 88]     ; height (mm)
    mov [r12 + ScreenInfo.phy_height], eax

    ; --- Calcular Pitch (LineLength) ---
    ; Pitch = Width * (BPP / 8)
    mov eax, [r12 + ScreenInfo.width]
    mov ecx, [r12 + ScreenInfo.bpp]
    shr ecx, 3              ; Dividir BPP entre 8
    imul eax, ecx           ; Multiplicar
    mov [r12 + ScreenInfo.pitch], eax

    ; --------------------------------------------------------------------------
    ; 5. LIMPIEZA Y SALIDA
    ; --------------------------------------------------------------------------
    add rsp, 160            ; Devolvemos la memoria del stack

    ; Cerrar archivo
    mov rax, 3              ; SYS_CLOSE
    mov rdi, rbx
    syscall

    mov rax, 0              ; Return 0 (Éxito)
    jmp .fin

.error_close:
    add rsp, 160            ; Restaurar stack antes de salir
    mov rax, 3
    mov rdi, rbx
    syscall

.error:
    mov rax, -1

.fin:
    pop r13
    pop r12
    pop rbx
    leave
    ret


==============================================================================
 RUTA: ./lib/graph/lib_graph_get_info_screen.inc
==============================================================================
; ==============================================================================
; Estructura ScreenInfo Actualizada
; Ahora incluye dimensiones físicas
; ==============================================================================

struc ScreenInfo
    .width      resd 1  ; 0: Ancho en Píxeles (px)
    .height     resd 1  ; 4: Alto en Píxeles (px)
    .bpp        resd 1  ; 8: Bits por Píxel
    .pitch      resd 1  ; 12: Bytes por Línea (LineLength)
    .phy_width  resd 1  ; 16: Ancho Físico (mm) [NUEVO]
    .phy_height resd 1  ; 20: Alto Físico (mm)  [NUEVO]
endstruc

; El tamaño total ahora es 24 bytes
ScreenInfo_size equ 24


==============================================================================
 RUTA: ./Makefile
==============================================================================
# ==============================================================================
# MAKEFILE: BINARIOS EN LA CARPETA DEL CÓDIGO FUENTE
# ==============================================================================

# --- 1. CONFIGURACIÓN ---
# Archivo principal (pasado por VS Code automáticamente vía tasks.json)
SRC ?= demo.asm

# Directorios de soporte
BUILD_DIR = build
LIB_DIR   = lib

# Herramientas y Flags
ASM = nasm
LD  = ld
ASM_FLAGS = -f elf64 -g -F dwarf -I./ -I./$(LIB_DIR)/
LD_FLAGS  = -m elf_x86_64

# --- 2. CÁLCULO DE RUTAS (LÓGICA ACTUALIZADA) ---

# TARGET_EXEC: Mantiene la ruta del SRC pero sin extensión
# Ejemplo: proyectos/mi_juego/main.asm -> proyectos/mi_juego/main
TARGET_EXEC = $(basename $(SRC))

# TARGET_OBJ: Mantiene la ruta del SRC pero con extensión .o
# Ejemplo: proyectos/mi_juego/main.asm -> proyectos/mi_juego/main.o
TARGET_OBJ  = $(basename $(SRC)).o

# --- LIBRERÍAS (Estas se quedan en build/ para limpieza) ---
LIB_SRCS := $(shell find $(LIB_DIR) -name '*.asm' 2>/dev/null)
LIB_OBJS := $(patsubst %.asm, $(BUILD_DIR)/%.o, $(LIB_SRCS))

# --- 3. REGLAS ---

.PHONY: all clean directories

all: directories $(TARGET_EXEC)

directories:
	@mkdir -p $(BUILD_DIR)
	@mkdir -p $(dir $(LIB_OBJS))

# --- VINCULACIÓN (LINKING) ---
# Crea el ejecutable final en la carpeta de origen
$(TARGET_EXEC): $(TARGET_OBJ) $(LIB_OBJS)
	@echo "[LD] Generando ejecutable: $@"
	@$(LD) $(LD_FLAGS) -o $@ $^

# --- ENSAMBLADO PRINCIPAL (EN TU CARPETA) ---
# Crea el .o en la carpeta de origen
$(TARGET_OBJ): $(SRC)
	@echo "[ASM] Ensamblando archivo local: $<"
	@$(ASM) $(ASM_FLAGS) -o $@ $<

# --- ENSAMBLADO DE LIBRERÍAS (EN BUILD) ---
$(BUILD_DIR)/%.o: %.asm
	@echo "[ASM] Ensamblando librería: $<"
	@mkdir -p $(dir $@)
	@$(ASM) $(ASM_FLAGS) -o $@ $<

# --- LIMPIEZA ---
# Borra la carpeta build Y TAMBIÉN los archivos generados localmente

# --- LIMPIEZA PROFUNDA (MODO ESCANER) ---
clean:
	@echo "[CLEAN] 1. Eliminando carpeta de librerías (build/)..."
	@rm -rf $(BUILD_DIR)

	@echo "[CLEAN] 2. Buscando y eliminando TODOS los archivos .o dispersos..."
	@find . -type f -name "*.o" -not -path "*/.git/*" -delete

	@echo "[CLEAN] 3. Eliminando ejecutables asociados a archivos .asm..."
	# Esta linea busca todos los archivos .asm, les quita la extensión
	# y borra el archivo ejecutable correspondiente si existe.
	@find . -type f -name "*.asm" -not -path "*/build/*" \
		| sed 's/\.asm$$//' \
		| xargs rm -f

	@echo "[LISTO] Proyecto limpio."


==============================================================================
 RUTA: ./proyectos/cnv/test_cnv.asm
==============================================================================
; ==============================================================================
; RUTA: ./proyectos/cnv/test_cnv.asm
; DESCRIPCIÓN: Programa para probar la librería lib_cnv_uint32_to_str
; ==============================================================================

default rel             ; IMPORTANTE: Direccionamiento relativo para 64 bits

section .data
    ; Mensajes para identificar cada prueba
    msg_titulo  db "--- TEST LIBRERIA CONVERSION ---", 10, 0
    msg_dec     db "1. Decimal (12345):      ", 0
    msg_hex     db "2. Hexadecimal (ADBEEF): ", 0
    msg_bin     db "3. Binario (255):        ", 0
    newline     db 10, 0

section .bss
    ; Buffer grande para el resultado (Binario necesita hasta 33 bytes)
    buffer_out  resb 64 

section .text
    global _start
    extern lib_cnv_uint32_to_str ; Importamos tu librería

_start:
    ; --- Imprimir Título ---
    lea rsi, [msg_titulo]
    call _print_str

    ; ==========================================================================
    ; PRUEBA 1: DECIMAL (Base 10)
    ; Convertiremos el número 12345
    ; ==========================================================================
    
    ; 1. Imprimir etiqueta
    lea rsi, [msg_dec]
    call _print_str

    ; 2. Preparar llamada a librería
    lea rdi, [buffer_out]   ; RDI = Dónde guardar el texto
    mov esi, 12345          ; ESI = Número a convertir
    mov edx, 255             ; EDX = Base (10 para Decimal)
    call lib_cnv_uint32_to_str

    ; 3. Imprimir resultado
    lea rsi, [buffer_out]
    call _print_str
    
    ; 4. Salto de línea
    lea rsi, [newline]
    call _print_str

    ; ==========================================================================
    ; PRUEBA 2: HEXADECIMAL (Base 16)
    ; Convertiremos el número 0xADBEEF (11386607)
    ; ==========================================================================
    
    lea rsi, [msg_hex]
    call _print_str

    lea rdi, [buffer_out]
    mov esi, 0xADBEEF       ; Número en formato Hex
    mov edx, 16             ; Base (16 para Hexadecimal)
    call lib_cnv_uint32_to_str

    lea rsi, [buffer_out]
    call _print_str
    
    lea rsi, [newline]
    call _print_str

    ; ==========================================================================
    ; PRUEBA 3: BINARIO (Base 2)
    ; Convertiremos el número 255 (debería ser 11111111)
    ; ==========================================================================
    
    lea rsi, [msg_bin]
    call _print_str

    lea rdi, [buffer_out]
    mov esi, 255            ; Número
    mov edx, 2              ; Base (2 para Binario)
    call lib_cnv_uint32_to_str

    lea rsi, [buffer_out]
    call _print_str
    
    lea rsi, [newline]
    call _print_str

    ; ==========================================================================
    ; FINALIZAR
    ; ==========================================================================
    mov rax, 60             ; sys_exit
    xor rdi, rdi            ; código 0
    syscall

; ------------------------------------------------------------------------------
; RUTINA AUXILIAR: Imprimir String terminada en 0
; Entradas: RSI = Puntero a la cadena
; ------------------------------------------------------------------------------
_print_str:
    push rax
    push rdi
    push rdx
    push rcx
    
    ; Calcular longitud (strlen)
    xor rdx, rdx
.count:
    cmp byte [rsi+rdx], 0
    je .write
    inc rdx
    jmp .count
.write:
    mov rax, 1              ; sys_write
    mov rdi, 1              ; stdout
    syscall

    pop rcx
    pop rdx
    pop rdi
    pop rax
    ret


==============================================================================
 RUTA: ./proyectos/graph/main.asm
==============================================================================
; ==============================================================================
; RUTA: ./proyectos/test_dpi.asm
; DESCRIPCIÓN: Muestra TODA la información técnica del monitor (PX, MM, BPP)
; ==============================================================================

default rel
%include "lib/graph/lib_graph_get_info_screen.inc" ; Tu estructura ScreenInfo

extern lib_graph_get_info_screen      ; Tu librería gráfica
extern lib_cnv_uint32_to_str   ; Tu librería de conversión

section .bss
    screen      resb ScreenInfo_size ; Reservamos 24 bytes para la estructura
    buffer_num  resb 32              ; Buffer para convertir números a texto

section .data
    ; --- Textos de Interfaz ---
    header      db 10, "=== REPORTE DE HARDWARE DE VIDEO ===", 10, 0
    
    lbl_res     db "Resolucion Logica:  ", 0
    lbl_phy     db "Tamano Fisico:      ", 0
    lbl_bpp     db "Profundidad Color:  ", 0
    lbl_pitch   db "Pitch (LineLength): ", 0
    
    sep_x       db " x ", 0          ; Separador " x "
    unit_px     db " px", 10, 0      ; Unidad pixeles + Salto linea
    unit_mm     db " mm", 10, 0      ; Unidad milimetros + Salto linea
    unit_bits   db " bits", 10, 0    ; Unidad bits + Salto linea
    unit_bytes  db " bytes", 10, 0   ; Unidad bytes + Salto linea
    
    err_msg     db "ERROR: No se pudo leer /dev/fb0", 10, 0

section .text
    global _start

_start:
    ; --------------------------------------------------------------------------
    ; 1. OBTENER INFORMACIÓN DEL KERNEL
    ; --------------------------------------------------------------------------
    lea rdi, [screen]           ; RDI apunta a nuestra estructura vacía
    call lib_graph_get_info_screen     ; Llenamos la estructura
    
    cmp rax, 0                  ; Verificamos errores
    jl .error_handler

    ; --------------------------------------------------------------------------
    ; 2. IMPRIMIR CABECERA
    ; --------------------------------------------------------------------------
    lea rsi, [header]
    call _print_str

    ; --------------------------------------------------------------------------
    ; 3. IMPRIMIR RESOLUCIÓN (Ancho x Alto px)
    ; --------------------------------------------------------------------------
    lea rsi, [lbl_res]          ; "Resolucion Logica: "
    call _print_str

    mov esi, [screen + ScreenInfo.width]
    call _print_number          ; Imprime Ancho
    
    lea rsi, [sep_x]            ; " x "
    call _print_str
    
    mov esi, [screen + ScreenInfo.height]
    call _print_number          ; Imprime Alto

    lea rsi, [unit_px]          ; " px"
    call _print_str

    ; --------------------------------------------------------------------------
    ; 4. IMPRIMIR TAMAÑO FÍSICO (Ancho x Alto mm)
    ; --------------------------------------------------------------------------
    lea rsi, [lbl_phy]          ; "Tamano Fisico: "
    call _print_str

    mov esi, [screen + ScreenInfo.phy_width]
    call _print_number
    
    lea rsi, [sep_x]            ; " x "
    call _print_str
    
    mov esi, [screen + ScreenInfo.phy_height]
    call _print_number

    lea rsi, [unit_mm]          ; " mm"
    call _print_str

    ; --------------------------------------------------------------------------
    ; 5. IMPRIMIR PROFUNDIDAD (BPP)
    ; --------------------------------------------------------------------------
    lea rsi, [lbl_bpp]          ; "Profundidad Color: "
    call _print_str

    mov esi, [screen + ScreenInfo.bpp]
    call _print_number

    lea rsi, [unit_bits]        ; " bits"
    call _print_str

    ; --------------------------------------------------------------------------
    ; 6. IMPRIMIR PITCH (Bytes por línea)
    ; --------------------------------------------------------------------------
    lea rsi, [lbl_pitch]        ; "Pitch (LineLength): "
    call _print_str

    mov esi, [screen + ScreenInfo.pitch]
    call _print_number

    lea rsi, [unit_bytes]       ; " bytes"
    call _print_str

    ; Salir con éxito
    mov rax, 60
    xor rdi, rdi
    syscall

.error_handler:
    lea rsi, [err_msg]
    call _print_str
    mov rax, 60
    mov rdi, 1
    syscall

; ==============================================================================
; RUTINAS AUXILIARES
; ==============================================================================

; ------------------------------------------------------------------------------
; _print_str: Imprime una cadena terminada en 0 apuntada por RSI
; ------------------------------------------------------------------------------
_print_str:
    push rdi
    push rdx
    push rcx
    push rax

    xor rdx, rdx                ; RDX = Longitud
.count:
    cmp byte [rsi + rdx], 0
    je .do_print
    inc rdx
    jmp .count
.do_print:
    mov rax, 1                  ; sys_write
    mov rdi, 1                  ; stdout
    syscall

    pop rax
    pop rcx
    pop rdx
    pop rdi
    ret

; ------------------------------------------------------------------------------
; _print_number: Convierte el número en ESI a texto e imprime
; Usa 'buffer_num' como memoria temporal
; ------------------------------------------------------------------------------
_print_number:
    push rdi
    push rdx
    push rsi ; Guardamos ESI porque la librería lo usa

    lea rdi, [buffer_num]       ; Buffer destino
    ; ESI ya tiene el número (pasado por el caller)
    mov edx, 10                 ; Base 10 (Decimal)
    call lib_cnv_uint32_to_str
    
    lea rsi, [buffer_num]       ; Preparamos para imprimir
    call _print_str

    pop rsi
    pop rdx
    pop rdi
    ret


==============================================================================
 RUTA: ./.vscode/extensions.json
==============================================================================
{
    "recommendations": [
        "ms-vscode.cpptools",             // C/C++ y Depurador
        "13xforever.language-x86-64-assembly", // Colores para ASM
        "DamianKoper.gdb-debug",          // Soporte extra GDB
        "mhutchie.git-graph"              // Visualizador de Git (Opcional)
    ]
}


==============================================================================
 RUTA: ./.vscode/launch.json
==============================================================================
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Depurar (GDB)",
            "type": "cppdbg",
            "request": "launch",
            // CAMBIO: Busca el ejecutable en la misma carpeta del archivo abierto
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": true,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "miDebuggerPath": "/usr/bin/gdb",
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Habilitar impresión bonita para gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Forzar arquitectura x86_64",
                    "text": "set architecture i386:x86-64",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "Construir Proyecto Actual"
        }
    ]
}


==============================================================================
 RUTA: ./.vscode/settings.json
==============================================================================
{
    "debug.allowBreakpointsEverywhere": true
}


==============================================================================
 RUTA: ./.vscode/tasks.json
==============================================================================
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Construir Proyecto Actual",
            "type": "shell",
            // Pasa el archivo abierto (${relativeFile}) a la variable SRC del Makefile
            "command": "make SRC=${relativeFile}", 
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "reveal": "always",
                "panel": "shared"
            },
            "problemMatcher": "$gcc"
        },
        {
            "label": "Limpiar Proyecto Actual",
            "type": "shell",
            "command": "make clean SRC=${relativeFile}"
        }
    ]
}


