==============================================================================
 RUTA: ./lib/cnv/lib_cnv_uint32_to_str.asm
==============================================================================
; ==============================================================================
; RUTA: ./lib/text/cnv_uint32_to_str/lib_cnv_uint32_to_str.asm
; DESCRIPCIÓN: Convierte un uint32 a string en la BASE especificada.
;
; ENTRADA:
;   RDI = Puntero al buffer de destino
;   ESI = Número entero sin signo (32 bits) a convertir
;   EDX = Base numérica (Ej: 10 para Decimal, 2 para Binario, 16 para Hex)
;
; SALIDA:
;   RAX = Puntero al inicio de la cadena (el mismo que RDI)
;   El buffer en RDI contendrá la cadena terminada en 0.
; ==============================================================================

default rel
section .text
    global lib_cnv_uint32_to_str

lib_cnv_uint32_to_str:
    push rbp
    mov rbp, rsp
    sub rsp, 16         ; Alineación

    push rbx            ; Guardamos registros protegidos
    push rdi            ; Guardamos el puntero inicial para devolverlo después

    ; Validación básica de la base (opcional, pero recomendada)
    ; Si la base es 0 o 1, forzamos base 10 para evitar bucles infinitos o crash
    cmp edx, 2
    jge .inicio
    mov edx, 10         ; Base por defecto si la entrada es inválida

.inicio:
    mov eax, esi        ; Número a convertir (Dividendo)
    mov ecx, edx        ; Base (Divisor) - Movemos de EDX a ECX para usarlo en div
    xor ebx, ebx        ; Contador de dígitos apilados

.bucle_division:
    xor edx, edx        ; Limpiar parte alta para la división (EDX:EAX)
    div ecx             ; EAX / Base --> EAX=Cociente, EDX=Resto
    
    ; Convertir el resto (0..Base-1) a ASCII
    cmp edx, 9
    jg .es_letra        ; Si es > 9 (para Hex), saltamos a letras

    add edx, '0'        ; 0-9 -> '0'-'9'
    jmp .push_digito

.es_letra:
    add edx, 'A' - 10   ; 10-15 -> 'A'-'F' (Útil si usas base 16)

.push_digito:
    push rdx            ; Guardamos el carácter en la pila
    inc ebx             ; Incrementamos contador
    
    test eax, eax       ; ¿El cociente es 0?
    jnz .bucle_division ; Si no, seguimos dividiendo

    ; Recuperar caracteres de la pila al buffer
    ; RDI ya apunta al inicio del buffer
.escribir:
    pop rdx
    mov [rdi], dl
    inc rdi
    dec ebx
    jnz .escribir

    mov byte [rdi], 0   ; Terminador nulo

    pop rax             ; Restauramos el puntero original en RAX (Return value)
    pop rbx             ; Restauramos RBX
    
    mov rsp, rbp
    pop rbp
    ret


==============================================================================
 RUTA: ./lib/cnv/lib_cnv_uint32_to_str.inc
==============================================================================
extern lib_cnv_uint32_to_str


==============================================================================
 RUTA: ./lib/constants.inc
==============================================================================
; ==============================================================================
; RUTA: lib/constants.inc
; DESCRIPCIÓN: Constantes globales del sistema (Linux x86_64)
; ==============================================================================

; --- Descriptores de Archivo ---
STDIN       equ 0
STDOUT      equ 1
STDERR      equ 2

; --- Números de Syscall ---
SYS_READ    equ 0
SYS_WRITE   equ 1
SYS_EXIT    equ 60

; --- Códigos de Salida ---
EXIT_SUCCESS equ 0


==============================================================================
 RUTA: ./lib/graph/lib_graph_get_info.asm
==============================================================================
; ==============================================================================
; RUTA: ./lib/graph/lib_graph_get_info.asm
; ESTRATEGIA: Híbrida.
; 1. Preguntamos al driver la Resolución y BPP (Extracción).
; 2. Calculamos el LineLength matemáticamente (Cálculo).
;    Esto evita el error "518" causado por leer mal la estructura fija.
; ==============================================================================

%include "lib/constants.inc"

; Solo necesitamos la info variable para saber el tamaño
FBIOGET_VSCREENINFO equ 0x4600  

default rel

section .text
    global lib_graph_get_info

lib_graph_get_info:
    push rbp
    mov rbp, rsp
    push rbx
    push rdi            ; Guardar puntero destino

    ; 1. ABRIR /dev/fb0
    mov rax, 2          ; SYS_OPEN
    lea rdi, [rel .dev_fb]
    mov rsi, 0          ; O_RDONLY
    syscall
    
    cmp rax, 0
    jl .error_open
    mov rbx, rax        ; Guardar File Descriptor

    ; 2. RESERVAR MEMORIA EN PILA (Solo para var_info es suficiente, 160 bytes)
    sub rsp, 160        

    ; 3. PEDIR DATOS DE RESOLUCIÓN (Ancho, Alto, BPP)
    mov rax, 16         ; SYS_IOCTL
    mov rdi, rbx
    mov rsi, FBIOGET_VSCREENINFO
    mov rdx, rsp        ; Puntero a la pila
    syscall
    
    test rax, rax
    jnz .error_ioctl

    ; 4. LEER Y CALCULAR
    ; Leemos lo que nos dijo el driver:
    mov r8d,  [rsp]         ; Ancho (xres) -> 1920
    mov r9d,  [rsp + 4]     ; Alto (yres)  -> 1080
    mov r10d, [rsp + 24]    ; BPP          -> 32

    ; --- AQUÍ ESTÁ EL TRUCO ---
    ; En lugar de leer el offset 48 de la otra estructura (que da 518 por error),
    ; calculamos el LineLength nosotros.
    ; FÓRMULA: LineLength = Ancho * (BPP / 8)
    
    mov r11d, r10d      ; R11D = 32
    shr r11d, 3         ; R11D = 32 / 8 = 4 (Bytes por pixel)
    imul r11d, r8d      ; R11D = 4 * 1920 = 7680
    
    ; Ahora R11D contiene 7680 garantizado.
    ; ---------------------------

    ; 5. LIMPIEZA
    add rsp, 160        ; Liberar pila
    mov rax, 3          ; SYS_CLOSE
    mov rdi, rbx
    syscall

    pop rdi             ; Recuperar puntero del usuario
    
    ; 6. ESCRIBIR RESULTADOS EN TU BUFFER
    mov [rdi], r8d      ; Ancho
    mov [rdi + 4], r9d  ; Alto
    mov [rdi + 8], r10d ; BPP
    mov [rdi + 12], r11d ; LineLength (El calculado: 7680)

    xor rax, rax        ; Return 0 (Éxito)
    jmp .fin

.error_ioctl:
    add rsp, 160
    mov rax, 3
    mov rdi, rbx
    syscall
    pop rdi
    mov rax, -1
    jmp .fin

.error_open:
    pop rdi
    mov rax, -1

.fin:
    pop rbx
    leave
    ret

section .data
    .dev_fb db "/dev/fb0", 0


==============================================================================
 RUTA: ./lib/graph/lib_graph_get_info.inc
==============================================================================
extern lib_graph_get_info


==============================================================================
 RUTA: ./Makefile
==============================================================================
# ==============================================================================
# MAKEFILE: BINARIOS EN LA CARPETA DEL CÓDIGO FUENTE
# ==============================================================================

# --- 1. CONFIGURACIÓN ---
# Archivo principal (pasado por VS Code automáticamente vía tasks.json)
SRC ?= demo.asm

# Directorios de soporte
BUILD_DIR = build
LIB_DIR   = lib

# Herramientas y Flags
ASM = nasm
LD  = ld
ASM_FLAGS = -f elf64 -g -F dwarf -I./ -I./$(LIB_DIR)/
LD_FLAGS  = -m elf_x86_64

# --- 2. CÁLCULO DE RUTAS (LÓGICA ACTUALIZADA) ---

# TARGET_EXEC: Mantiene la ruta del SRC pero sin extensión
# Ejemplo: proyectos/mi_juego/main.asm -> proyectos/mi_juego/main
TARGET_EXEC = $(basename $(SRC))

# TARGET_OBJ: Mantiene la ruta del SRC pero con extensión .o
# Ejemplo: proyectos/mi_juego/main.asm -> proyectos/mi_juego/main.o
TARGET_OBJ  = $(basename $(SRC)).o

# --- LIBRERÍAS (Estas se quedan en build/ para limpieza) ---
LIB_SRCS := $(shell find $(LIB_DIR) -name '*.asm' 2>/dev/null)
LIB_OBJS := $(patsubst %.asm, $(BUILD_DIR)/%.o, $(LIB_SRCS))

# --- 3. REGLAS ---

.PHONY: all clean directories

all: directories $(TARGET_EXEC)

directories:
	@mkdir -p $(BUILD_DIR)
	@mkdir -p $(dir $(LIB_OBJS))

# --- VINCULACIÓN (LINKING) ---
# Crea el ejecutable final en la carpeta de origen
$(TARGET_EXEC): $(TARGET_OBJ) $(LIB_OBJS)
	@echo "[LD] Generando ejecutable: $@"
	@$(LD) $(LD_FLAGS) -o $@ $^

# --- ENSAMBLADO PRINCIPAL (EN TU CARPETA) ---
# Crea el .o en la carpeta de origen
$(TARGET_OBJ): $(SRC)
	@echo "[ASM] Ensamblando archivo local: $<"
	@$(ASM) $(ASM_FLAGS) -o $@ $<

# --- ENSAMBLADO DE LIBRERÍAS (EN BUILD) ---
$(BUILD_DIR)/%.o: %.asm
	@echo "[ASM] Ensamblando librería: $<"
	@mkdir -p $(dir $@)
	@$(ASM) $(ASM_FLAGS) -o $@ $<

# --- LIMPIEZA ---
# Borra la carpeta build Y TAMBIÉN los archivos generados localmente

# --- LIMPIEZA PROFUNDA (MODO ESCANER) ---
clean:
	@echo "[CLEAN] 1. Eliminando carpeta de librerías (build/)..."
	@rm -rf $(BUILD_DIR)

	@echo "[CLEAN] 2. Buscando y eliminando TODOS los archivos .o dispersos..."
	@find . -type f -name "*.o" -not -path "*/.git/*" -delete

	@echo "[CLEAN] 3. Eliminando ejecutables asociados a archivos .asm..."
	# Esta linea busca todos los archivos .asm, les quita la extensión
	# y borra el archivo ejecutable correspondiente si existe.
	@find . -type f -name "*.asm" -not -path "*/build/*" \
		| sed 's/\.asm$$//' \
		| xargs rm -f

	@echo "[LISTO] Proyecto limpio."


==============================================================================
 RUTA: ./proyectos/demo/demo.asm
==============================================================================
; ==============================================================================
; ARCHIVO: demo.asm
; DESCRIPCIÓN: Ejemplo básico de uso del framework.
;              Muestra cómo imprimir texto y usar la librería de números.
; ==============================================================================

; 1. Inclusión de constantes y librerías
;    (Las rutas siempre son relativas a la raíz del proyecto)
%include "lib/constants.inc"
%include "lib/text/print_dec32/lib_text_print_dec32.inc"

; 2. Configuración obligatoria para 64-bits
default rel

section .data
    ; Definimos un mensaje con salto de línea (10) y terminador nulo (0)
    msg_hola    db "Hola, mundo desde Assembly x64!", 10, 0
    
    ; Calculamos la longitud automáticamente
    len_hola    equ $ - msg_hola

section .text
    global _start

_start:
    ; --------------------------------------------------------------------------
    ; 1. Imprimir un mensaje de texto simple (Syscall directa)
    ; --------------------------------------------------------------------------
    mov rax, SYS_WRITE      ; Syscall ID: 1 (Write)
    mov rdi, STDOUT         ; Descriptor: 1 (Salida estándar)
    lea rsi, [msg_hola]     ; Dirección del mensaje
    mov rdx, len_hola       ; Longitud del mensaje
    syscall

    ; --------------------------------------------------------------------------
    ; 2. Usar la librería propia para imprimir un número
    ; --------------------------------------------------------------------------
    ; La función espera el número en el registro EDI (32 bits)
    mov edi, -12345         
    call lib_text_print_dec32 

    ; --------------------------------------------------------------------------
    ; 3. Salida limpia del programa
    ; --------------------------------------------------------------------------
    mov rax, SYS_EXIT       ; Syscall ID: 60 (Exit)
    mov rdi, EXIT_SUCCESS   ; Código de retorno: 0 (Todo bien)
    syscall


==============================================================================
 RUTA: ./proyectos/graph/main.asm
==============================================================================
; ==============================================================================
; RUTA: ./proyectos/graph/main.asm
; DESCRIPCIÓN: Muestra TODA la info de la pantalla (Ancho, Alto, BPP, LineLen)
; ==============================================================================

%include "lib/constants.inc"
%include "lib/cnv/lib_cnv_uint32_to_str.inc"

extern lib_graph_get_info

default rel

section .data
    txt_w       db "Ancho:      ", 0
    txt_h       db "Alto:       ", 0
    txt_bpp     db "BPP:        ", 0
    txt_len     db "LineLength: ", 0
    newline     db 10, 0

section .bss
    ; Estructura: [0]=Ancho, [4]=Alto, [8]=BPP, [12]=LineLen
    screen_info resd 4      
    text_buf    resb 16

section .text
    global _start

_start:
    ; 1. LLAMAR A LA LIBRERÍA
    lea rdi, [screen_info]
    call lib_graph_get_info

    cmp rax, 0
    jl .error

    ; --------------------------------------------------------------------------
    ; 2. MOSTRAR DATOS UNO POR UNO
    ; --------------------------------------------------------------------------

    ; --- DATO 1: ANCHO (Offset 0) ---
    lea rsi, [txt_w]        ; Etiqueta
    call _print_str
    
    mov esi, [screen_info]  ; Valor
    call _print_num_ln      ; Imprimir número + enter

    ; --- DATO 2: ALTO (Offset 4) ---
    lea rsi, [txt_h]
    call _print_str
    
    mov esi, [screen_info + 4] ; Desplazamos 4 bytes
    call _print_num_ln

    ; --- DATO 3: BITS POR PIXEL (Offset 8) ---
    lea rsi, [txt_bpp]
    call _print_str
    
    mov esi, [screen_info + 8] ; Desplazamos 8 bytes
    call _print_num_ln

    ; --- DATO 4: LINE LENGTH (Offset 12) ---
    ; ¡Este dato es vital! Es el ancho REAL en memoria (puede ser mayor al ancho visible)
    lea rsi, [txt_len]
    call _print_str
    
    mov esi, [screen_info + 12] ; Desplazamos 12 bytes
    call _print_num_ln

    ; SALIR
    mov rax, SYS_EXIT
    xor rdi, rdi
    syscall

.error:
    ; Si falla, devolvemos 1
    mov rax, SYS_EXIT
    mov rdi, 1
    syscall

; ==============================================================================
; RUTINAS AUXILIARES
; ==============================================================================

; Imprime el número en ESI seguido de un salto de línea
_print_num_ln:
    lea rdi, [text_buf]
    mov edx, 10
    call lib_cnv_uint32_to_str
    
    lea rsi, [text_buf]
    call _print_str
    
    lea rsi, [newline]
    call _print_str
    ret

; Imprime cadena terminada en 0
_print_str:
    push rax
    push rdi
    push rdx
    push rsi                ; Guardamos RSI porque lo modificamos
    
    ; Calcular longitud (strlen rápido)
    xor rdx, rdx
.loop:
    cmp byte [rsi+rdx], 0
    je .print
    inc rdx
    jmp .loop
.print:
    mov rax, SYS_WRITE
    mov rdi, STDOUT
    syscall
    
    pop rsi
    pop rdx
    pop rdi
    pop rax
    ret


==============================================================================
 RUTA: ./.vscode/extensions.json
==============================================================================
{
    "recommendations": [
        "ms-vscode.cpptools",             // C/C++ y Depurador
        "13xforever.language-x86-64-assembly", // Colores para ASM
        "DamianKoper.gdb-debug",          // Soporte extra GDB
        "mhutchie.git-graph"              // Visualizador de Git (Opcional)
    ]
}


==============================================================================
 RUTA: ./.vscode/launch.json
==============================================================================
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Depurar (GDB)",
            "type": "cppdbg",
            "request": "launch",
            // CAMBIO: Busca el ejecutable en la misma carpeta del archivo abierto
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": true,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "miDebuggerPath": "/usr/bin/gdb",
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Habilitar impresión bonita para gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Forzar arquitectura x86_64",
                    "text": "set architecture i386:x86-64",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "Construir Proyecto Actual"
        }
    ]
}


==============================================================================
 RUTA: ./.vscode/settings.json
==============================================================================
{
    "debug.allowBreakpointsEverywhere": true
}


==============================================================================
 RUTA: ./.vscode/tasks.json
==============================================================================
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Construir Proyecto Actual",
            "type": "shell",
            // Pasa el archivo abierto (${relativeFile}) a la variable SRC del Makefile
            "command": "make SRC=${relativeFile}", 
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "reveal": "always",
                "panel": "shared"
            },
            "problemMatcher": "$gcc"
        },
        {
            "label": "Limpiar Proyecto Actual",
            "type": "shell",
            "command": "make clean SRC=${relativeFile}"
        }
    ]
}


