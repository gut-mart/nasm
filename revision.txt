==============================================================================
 RUTA: ./lib/cnv/lib_cnv_uint32_to_str.asm
==============================================================================
; ==============================================================================
; RUTA: ./lib/text/cnv_uint32_to_str/lib_cnv_uint32_to_str.asm
; DESCRIPCIÓN: Convierte un uint32 a string en la BASE especificada.
;
; ENTRADA:
;   RDI = Puntero al buffer de destino
;   ESI = Número entero sin signo (32 bits) a convertir
;   EDX = Base numérica (Ej: 10 para Decimal, 2 para Binario, 16 para Hex)
;
; SALIDA:
;   RAX = Puntero al inicio de la cadena (el mismo que RDI)
;   El buffer en RDI contendrá la cadena terminada en 0.
; ==============================================================================

default rel
section .text
    global lib_cnv_uint32_to_str

lib_cnv_uint32_to_str:
    push rbp
    mov rbp, rsp
    sub rsp, 16         ; Alineación

    push rbx            ; Guardamos registros protegidos
    push rdi            ; Guardamos el puntero inicial para devolverlo después

    ; Validación básica de la base (opcional, pero recomendada)
    ; Si la base es 0 o 1, forzamos base 10 para evitar bucles infinitos o crash
    cmp edx, 2
    jge .inicio
    mov edx, 10         ; Base por defecto si la entrada es inválida

.inicio:
    mov eax, esi        ; Número a convertir (Dividendo)
    mov ecx, edx        ; Base (Divisor) - Movemos de EDX a ECX para usarlo en div
    xor ebx, ebx        ; Contador de dígitos apilados

.bucle_division:
    xor edx, edx        ; Limpiar parte alta para la división (EDX:EAX)
    div ecx             ; EAX / Base --> EAX=Cociente, EDX=Resto
    
    ; Convertir el resto (0..Base-1) a ASCII
    cmp edx, 9
    jg .es_letra        ; Si es > 9 (para Hex), saltamos a letras

    add edx, '0'        ; 0-9 -> '0'-'9'
    jmp .push_digito

.es_letra:
    add edx, 'A' - 10   ; 10-15 -> 'A'-'F' (Útil si usas base 16)

.push_digito:
    push rdx            ; Guardamos el carácter en la pila
    inc ebx             ; Incrementamos contador
    
    test eax, eax       ; ¿El cociente es 0?
    jnz .bucle_division ; Si no, seguimos dividiendo

    ; Recuperar caracteres de la pila al buffer
    ; RDI ya apunta al inicio del buffer
.escribir:
    pop rdx
    mov [rdi], dl
    inc rdi
    dec ebx
    jnz .escribir

    mov byte [rdi], 0   ; Terminador nulo

    pop rax             ; Restauramos el puntero original en RAX (Return value)
    pop rbx             ; Restauramos RBX
    
    mov rsp, rbp
    pop rbp
    ret


==============================================================================
 RUTA: ./lib/cnv/lib_cnv_uint32_to_str.inc
==============================================================================
extern lib_cnv_uint32_to_str


==============================================================================
 RUTA: ./lib/constants.inc
==============================================================================
; ==============================================================================
; RUTA: lib/constants.inc
; DESCRIPCIÓN: Constantes globales del sistema (Linux x86_64)
; ==============================================================================

; --- Descriptores de Archivo ---
STDIN       equ 0
STDOUT      equ 1
STDERR      equ 2

; --- Números de Syscall ---
SYS_READ    equ 0
SYS_WRITE   equ 1
SYS_EXIT    equ 60

; --- Códigos de Salida ---
EXIT_SUCCESS equ 0


==============================================================================
 RUTA: ./lib/graph/lib_graph_get_info.asm
==============================================================================
; ==============================================================================
; RUTA: ./lib/graph/lib_graph_get_info.asm
; DESCRIPCIÓN: Librería para obtener geometría de pantalla desde /dev/fb0.
; ==============================================================================

%include "lib/constants.inc"
%include "lib/graph/lib_graph_get_info.inc"

; Constantes internas
FBIOGET_VSCREENINFO equ 0x4600  
SYS_OPEN            equ 2
SYS_CLOSE           equ 3
SYS_IOCTL           equ 16
O_RDONLY            equ 0

default rel

section .data
    dev_fb db "/dev/fb0", 0

section .text
    global lib_graph_get_info

; ------------------------------------------------------------------------------
; FUNCIÓN: lib_graph_get_info
; ENTRADA: RDI = Puntero a una estructura ScreenInfo donde guardar los datos
; SALIDA:  RAX = 0 (Éxito), -1 (Error)
; ------------------------------------------------------------------------------
lib_graph_get_info:
    push rbp
    mov rbp, rsp
    push rbx
    push r12                ; Guardamos registros callee-saved
    
    mov r12, rdi            ; R12 = Puntero del usuario (ScreenInfo)

    ; 1. ABRIR /dev/fb0
    mov rax, SYS_OPEN
    lea rdi, [dev_fb]
    mov rsi, O_RDONLY
    syscall
    
    cmp rax, 0
    jl .error
    mov rbx, rax            ; RBX = File Descriptor

    ; 2. RESERVAR BUFFER TEMPORAL PARA IOCTL
    sub rsp, 160            ; Estructura fb_var_screeninfo del kernel

    ; 3. CONSULTAR AL DRIVER (IOCTL)
    mov rax, SYS_IOCTL
    mov edi, ebx            ; FD
    mov rsi, FBIOGET_VSCREENINFO
    mov rdx, rsp            ; Puntero al stack
    syscall

    test rax, rax
    jnz .error_close

    ; 4. EXTRAER Y CALCULAR
    ; Leemos del stack lo que dijo el kernel
    mov r8d,  [rsp]         ; Offset 0:  xres (Ancho)
    mov r9d,  [rsp + 4]     ; Offset 4:  yres (Alto)
    mov r10d, [rsp + 24]    ; Offset 24: bits_per_pixel

    ; Calculamos el Pitch (LineLength) matemáticamente
    ; Pitch = Ancho * (BPP / 8)
    mov r11d, r10d
    shr r11d, 3             ; Dividir bits entre 8 para sacar bytes
    imul r11d, r8d          ; Multiplicar por el ancho

    ; 5. GUARDAR EN LA ESTRUCTURA DEL USUARIO (R12)
    mov [r12 + ScreenInfo.width],  r8d
    mov [r12 + ScreenInfo.height], r9d
    mov [r12 + ScreenInfo.bpp],    r10d
    mov [r12 + ScreenInfo.pitch],  r11d  ; ¡Aquí va el 7680!

    ; 6. LIMPIEZA
    add rsp, 160            ; Liberar buffer temporal
    
    mov rax, SYS_CLOSE      ; Cerrar archivo
    mov edi, ebx
    syscall

    xor rax, rax            ; Return 0 (Éxito)
    jmp .fin

.error_close:
    add rsp, 160
    mov rax, SYS_CLOSE
    mov edi, ebx
    syscall
    mov rax, -1
    jmp .fin

.error:
    mov rax, -1

.fin:
    pop r12
    pop rbx
    leave
    ret


==============================================================================
 RUTA: ./lib/graph/lib_graph_get_info.inc
==============================================================================
; ==============================================================================
; RUTA: ./lib/graph/lib_graph_info.inc
; DESCRIPCIÓN: Definición de la estructura de información de pantalla.
; ==============================================================================

struc ScreenInfo
    .width      resd 1  ; 4 bytes - Ancho (xres)
    .height     resd 1  ; 4 bytes - Alto (yres)
    .bpp        resd 1  ; 4 bytes - Bits por Pixel
    .pitch      resd 1  ; 4 bytes - LineLength (Bytes por línea REALES)
endstruc

; Tamaño total de la estructura (para reservar memoria con resb)
ScreenInfo_size equ 16


==============================================================================
 RUTA: ./Makefile
==============================================================================
# ==============================================================================
# MAKEFILE: BINARIOS EN LA CARPETA DEL CÓDIGO FUENTE
# ==============================================================================

# --- 1. CONFIGURACIÓN ---
# Archivo principal (pasado por VS Code automáticamente vía tasks.json)
SRC ?= demo.asm

# Directorios de soporte
BUILD_DIR = build
LIB_DIR   = lib

# Herramientas y Flags
ASM = nasm
LD  = ld
ASM_FLAGS = -f elf64 -g -F dwarf -I./ -I./$(LIB_DIR)/
LD_FLAGS  = -m elf_x86_64

# --- 2. CÁLCULO DE RUTAS (LÓGICA ACTUALIZADA) ---

# TARGET_EXEC: Mantiene la ruta del SRC pero sin extensión
# Ejemplo: proyectos/mi_juego/main.asm -> proyectos/mi_juego/main
TARGET_EXEC = $(basename $(SRC))

# TARGET_OBJ: Mantiene la ruta del SRC pero con extensión .o
# Ejemplo: proyectos/mi_juego/main.asm -> proyectos/mi_juego/main.o
TARGET_OBJ  = $(basename $(SRC)).o

# --- LIBRERÍAS (Estas se quedan en build/ para limpieza) ---
LIB_SRCS := $(shell find $(LIB_DIR) -name '*.asm' 2>/dev/null)
LIB_OBJS := $(patsubst %.asm, $(BUILD_DIR)/%.o, $(LIB_SRCS))

# --- 3. REGLAS ---

.PHONY: all clean directories

all: directories $(TARGET_EXEC)

directories:
	@mkdir -p $(BUILD_DIR)
	@mkdir -p $(dir $(LIB_OBJS))

# --- VINCULACIÓN (LINKING) ---
# Crea el ejecutable final en la carpeta de origen
$(TARGET_EXEC): $(TARGET_OBJ) $(LIB_OBJS)
	@echo "[LD] Generando ejecutable: $@"
	@$(LD) $(LD_FLAGS) -o $@ $^

# --- ENSAMBLADO PRINCIPAL (EN TU CARPETA) ---
# Crea el .o en la carpeta de origen
$(TARGET_OBJ): $(SRC)
	@echo "[ASM] Ensamblando archivo local: $<"
	@$(ASM) $(ASM_FLAGS) -o $@ $<

# --- ENSAMBLADO DE LIBRERÍAS (EN BUILD) ---
$(BUILD_DIR)/%.o: %.asm
	@echo "[ASM] Ensamblando librería: $<"
	@mkdir -p $(dir $@)
	@$(ASM) $(ASM_FLAGS) -o $@ $<

# --- LIMPIEZA ---
# Borra la carpeta build Y TAMBIÉN los archivos generados localmente

# --- LIMPIEZA PROFUNDA (MODO ESCANER) ---
clean:
	@echo "[CLEAN] 1. Eliminando carpeta de librerías (build/)..."
	@rm -rf $(BUILD_DIR)

	@echo "[CLEAN] 2. Buscando y eliminando TODOS los archivos .o dispersos..."
	@find . -type f -name "*.o" -not -path "*/.git/*" -delete

	@echo "[CLEAN] 3. Eliminando ejecutables asociados a archivos .asm..."
	# Esta linea busca todos los archivos .asm, les quita la extensión
	# y borra el archivo ejecutable correspondiente si existe.
	@find . -type f -name "*.asm" -not -path "*/build/*" \
		| sed 's/\.asm$$//' \
		| xargs rm -f

	@echo "[LISTO] Proyecto limpio."


==============================================================================
 RUTA: ./proyectos/demo/demo.asm
==============================================================================
; ==============================================================================
; ARCHIVO: demo.asm
; DESCRIPCIÓN: Ejemplo básico de uso del framework.
;              Muestra cómo imprimir texto y usar la librería de números.
; ==============================================================================

; 1. Inclusión de constantes y librerías
;    (Las rutas siempre son relativas a la raíz del proyecto)
%include "lib/constants.inc"
%include "lib/text/print_dec32/lib_text_print_dec32.inc"

; 2. Configuración obligatoria para 64-bits
default rel

section .data
    ; Definimos un mensaje con salto de línea (10) y terminador nulo (0)
    msg_hola    db "Hola, mundo desde Assembly x64!", 10, 0
    
    ; Calculamos la longitud automáticamente
    len_hola    equ $ - msg_hola

section .text
    global _start

_start:
    ; --------------------------------------------------------------------------
    ; 1. Imprimir un mensaje de texto simple (Syscall directa)
    ; --------------------------------------------------------------------------
    mov rax, SYS_WRITE      ; Syscall ID: 1 (Write)
    mov rdi, STDOUT         ; Descriptor: 1 (Salida estándar)
    lea rsi, [msg_hola]     ; Dirección del mensaje
    mov rdx, len_hola       ; Longitud del mensaje
    syscall

    ; --------------------------------------------------------------------------
    ; 2. Usar la librería propia para imprimir un número
    ; --------------------------------------------------------------------------
    ; La función espera el número en el registro EDI (32 bits)
    mov edi, -12345         
    call lib_text_print_dec32 

    ; --------------------------------------------------------------------------
    ; 3. Salida limpia del programa
    ; --------------------------------------------------------------------------
    mov rax, SYS_EXIT       ; Syscall ID: 60 (Exit)
    mov rdi, EXIT_SUCCESS   ; Código de retorno: 0 (Todo bien)
    syscall


==============================================================================
 RUTA: ./proyectos/graph/main.asm
==============================================================================
; ==============================================================================
; RUTA: ./proyectos/graph/main.asm
; ==============================================================================

%include "lib/graph/lib_graph_get_info.inc"

extern lib_graph_get_info

default rel

; ------------------------------------------------------------------------------
; SECCIÓN BSS (Datos no inicializados)
; ------------------------------------------------------------------------------
section .bss
    mi_pantalla resb ScreenInfo_size   ; Estructura para recibir los datos

; ------------------------------------------------------------------------------
; SECCIÓN DATA (Datos inicializados - MÁS SEGURO)
; ------------------------------------------------------------------------------
section .data
    msg_titulo db "--- INFO PANTALLA ---", 10, 0
    msg_ancho  db "Ancho (xres): ", 0
    msg_alto   db "Alto  (yres): ", 0
    msg_bpp    db "BPP:          ", 0
    msg_pitch  db "LineLength:   ", 0
    newline    db 10, 0
    
    ; ¡TRUCO! Inicializamos el buffer con ceros aquí para asegurar que la memoria existe.
    ; Reservamos 32 bytes llenos de ceros.
    buffer_num times 32 db 0 

section .text
    global _start

_start:
    ; 1. OBTENER INFORMACIÓN
    lea rdi, [mi_pantalla]
    call lib_graph_get_info
    
    cmp rax, 0
    jl .error

    ; 2. IMPRIMIR TÍTULO
    lea rsi, [msg_titulo]
    call _print_str

    ; 3. IMPRIMIR ANCHO
    lea rsi, [msg_ancho]
    call _print_str
    
    mov edi, [mi_pantalla + ScreenInfo.width]
    call _print_num_ln

    ; 4. IMPRIMIR ALTO
    lea rsi, [msg_alto]
    call _print_str
    
    mov edi, [mi_pantalla + ScreenInfo.height]
    call _print_num_ln

    ; 5. IMPRIMIR BPP
    lea rsi, [msg_bpp]
    call _print_str
    
    mov edi, [mi_pantalla + ScreenInfo.bpp]
    call _print_num_ln

    ; 6. IMPRIMIR PITCH (LINELENGTH)
    lea rsi, [msg_pitch]
    call _print_str
    
    mov edi, [mi_pantalla + ScreenInfo.pitch]
    call _print_num_ln

    ; SALIR (ÉXITO)
    mov rax, 60         ; SYS_EXIT
    xor rdi, rdi
    syscall

.error:
    ; SALIR (ERROR)
    mov rax, 60
    mov rdi, 1
    syscall

; ==============================================================================
; RUTINAS AUXILIARES ROBUSTAS
; ==============================================================================

; --- _print_str: Imprime hasta encontrar un 0 ---
_print_str:
    push rax
    push rdi
    push rdx
    push rcx
    push rsi            ; Guardamos RSI por seguridad

    ; Calcular longitud (strlen)
    xor rdx, rdx        ; RDX = 0
.len_loop:
    cmp byte [rsi+rdx], 0
    je .do_write
    inc rdx
    jmp .len_loop

.do_write:
    test rdx, rdx       ; Si longitud es 0, no imprimimos nada
    jz .exit_print
    
    mov rax, 1          ; SYS_WRITE
    mov rdi, 1          ; STDOUT
    ; RSI ya apunta al string
    ; RDX ya tiene la longitud
    syscall

.exit_print:
    pop rsi
    pop rcx
    pop rdx
    pop rdi
    pop rax
    ret

; --- _print_num_ln: Convierte EDI a texto y lo imprime + Enter ---
_print_num_ln:
    push rax
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi

    mov eax, edi                ; Número a convertir
    
    ; Usamos el buffer en .data (buffer_num)
    ; Apuntamos al final del buffer (byte 30) para escribir hacia atrás
    lea rsi, [buffer_num + 30]  
    mov byte [rsi], 0           ; Terminador nulo al final
    
    mov ebx, 10                 ; Divisor

.convert_loop:
    xor edx, edx                ; Limpiar parte alta para división
    div ebx                     ; EAX / 10 -> Cociente EAX, Resto EDX
    
    add dl, '0'                 ; Convertir número a ASCII
    dec rsi                     ; Retroceder en el buffer
    mov [rsi], dl               ; Guardar letra
    
    test eax, eax               ; ¿Queda número?
    jnz .convert_loop           ; Si no es 0, repetir

    ; Ahora RSI apunta al principio del número generado. Imprimimos.
    call _print_str
    
    ; Imprimir salto de línea
    lea rsi, [newline]
    call _print_str

    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    pop rax
    ret


==============================================================================
 RUTA: ./.vscode/extensions.json
==============================================================================
{
    "recommendations": [
        "ms-vscode.cpptools",             // C/C++ y Depurador
        "13xforever.language-x86-64-assembly", // Colores para ASM
        "DamianKoper.gdb-debug",          // Soporte extra GDB
        "mhutchie.git-graph"              // Visualizador de Git (Opcional)
    ]
}


==============================================================================
 RUTA: ./.vscode/launch.json
==============================================================================
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Depurar (GDB)",
            "type": "cppdbg",
            "request": "launch",
            // CAMBIO: Busca el ejecutable en la misma carpeta del archivo abierto
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": true,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "miDebuggerPath": "/usr/bin/gdb",
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Habilitar impresión bonita para gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Forzar arquitectura x86_64",
                    "text": "set architecture i386:x86-64",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "Construir Proyecto Actual"
        }
    ]
}


==============================================================================
 RUTA: ./.vscode/settings.json
==============================================================================
{
    "debug.allowBreakpointsEverywhere": true
}


==============================================================================
 RUTA: ./.vscode/tasks.json
==============================================================================
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Construir Proyecto Actual",
            "type": "shell",
            // Pasa el archivo abierto (${relativeFile}) a la variable SRC del Makefile
            "command": "make SRC=${relativeFile}", 
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "reveal": "always",
                "panel": "shared"
            },
            "problemMatcher": "$gcc"
        },
        {
            "label": "Limpiar Proyecto Actual",
            "type": "shell",
            "command": "make clean SRC=${relativeFile}"
        }
    ]
}


